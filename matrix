#!/bin/bash -e

function errorReturn() {
	return 1
}

function dims() {
	# NAME	
	# 	dims - Give the dimensions (rows and columns) of a given matrix
	# SYNOPSIS
	# 	Generates rows and columns of a given matrix in a file
	# DESCRIPTION
	# 	TODO
	# AUTHOR
	# 	Written by Jett Seale (sealee@oregonstate.edu)

	ROWS=$(wc -l < $1) # Counts the number of lines in the file with the matrix, which if formatted correctly will correspond to the number of rows
		
	words=$(wc -w < $1) # Counts the number of words in the file with the matrix
	COLS=$((words / ROWS)) # Divide the number of words by the number of rows to get columns

	echo $ROWS $COLS

	return 0
}

function transpose() {
	# NAME	
	# 	transpose - Give the dimensions (rows and columns) of a given matrix
	# SYNOPSIS
	# 	Generates rows and columns of a given matrix in a file
	# DESCRIPTION
	# 	TODO
	# AUTHOR
	# 	Written by Jett Seale (sealee@oregonstate.edu)

	tempfile="tempfile$$" # Generate a temp file
	finalfile="finalfile$$" # Output file

	rows=$(wc -l < "$1")
	words=$(wc -w < "$1")
	cols=$((words / rows)) # Get the number of columns to find out how many times to loop

	for ((i=1; i<=cols; i++)); do # For each column in the matrix
		echo "$(cut -f $i $1)" > "$tempfile" # Cut the ith column and store it in a temp file
		echo "$(paste -s "$tempfile")" >> "$finalfile" # Paste the column in the temp file (inserts a tab after each element and a newline at the end) and append to finalfile
	done

	cat "$finalfile" # Print the final output

	rm -f "$tempfile" "$finalfile" # Delete the temp files
	return 0
}

function mean() {
	# Header TODO

	tempfile="tempfile$$" # Generate temp file
	secondtempfile="secondtempfile$$" # Second temp file
	finalfile="finalfile$$" # Output file

	rows=$(wc -l < "$1")
	words=$(wc -w < "$1")
	cols=$((words / rows)) # Get number of cols to set as the number of times to loop
	
	for ((i=1; i<=cols; i++)); do # For each col in matrix
		echo "$(cut -f $i $1)" > "$tempfile" # Cut the ith col and store in temp file
		subrows=$(wc -l < "$tempfile") # Get the number of rows in the ith column temp file to use for inner loop
		finalnum=0 
		for ((j=1; j<=subrows; j++)); do # For each row in the ith col
			tempnum=$(cat "$tempfile" | head -"$j" | tail -1) # Get the element from the jth row and assign it to tempnum
			finalnum=$((finalnum + tempnum)) # Add the temp number to the total number
		done
		finalnum=$((finalnum / subrows)) # Divide all the added up column numbers by the total number of rows in that column
		echo "$finalnum" >> "$secondtempfile" # Save the average number
	done

	cat "$secondtempfile" | tr '\n' '\t' > "$finalfile" # Turn the column result into a row
	
	truncate -s-1 "$finalfile" # Get rid of the trailing tab char

	echo -e "" >> "$finalfile" # Add a newline char at the end of the file

	cat "$finalfile" # Print the final output

	rm -f "$tempfile" "$secondtempfile" "$finalfile" # Delete temp files
	return 0	
}

function add() {
	# Header TODO

	m1rows=$(wc -l < "$1")
	m1words=$(wc -w < "$1")
	m1cols=$((m1words / m1rows))

	m2rows=$(wc -l < "$2")
	m2words=$(wc -w < "$2")
	m2cols=$((m2words / m2rows))

	if [[ "$m1rows" = "$m2rows" && "$m1cols" = "$m2cols" ]]
	then
		tempfilem1="tempfilem1$$"
		tempfilem2="tempfilem2$$"
		addedrow=""
		for ((i=1; i<=m1rows; i++)); do 
			echo "$(cat "$1" | head -"$i" | tail -1)" > "$tempfilem1"
			echo "$(cat "$2" | head -"$i" | tail -1)" > "$tempfilem2"
			subcols=$(wc -w < "$tempfilem1")
			for ((j=1; j<=subcols; j++)); do
				tempnumm1="$(cut -f $j $tempfilem1)"
				tempnumm2="$(cut -f $j $tempfilem2)"
				addednum=$((tempnumm1 + tempnumm2))
				if [ "$j" = "$subcols" ]
				then
					addedrow="$addedrow$addednum\n"
				else
					addedrow="$addedrow$addednum\t"
				fi
			done
		done

		addedrow=${addedrow%?}
		addedrow=${addedrow%?}
		echo -e "$addedrow"

		rm -f "$tempfilem1" "$tempfilem2"
	else
		>&2 echo The rows and/or columns of your two matrices are not compatible to add
		errorReturn
	fi			
}

#function multiply() {}

# MAIN PROG:

# Routes to different functions based on first arg value:
if [ "$1" = "dims" ] #If first arg is dims, call dims function
then
	datafilepath="datafile$$" # Generate a random file
	if [ "$#" = "1" ] # If the number of args is equal to one then read input from stdin into the random file
	then
		cat > "$datafilepath"
	elif [ "$#" = "2" ] # If number of args is two then assign the passed file to the random file
	then
		if [[ -r $2 ]]
		then
			datafilepath=$2
		else 
			>&2 echo The file you gave is not readable
			errorReturn
		fi
	else
		>&2 echo You did not pass the correct number of arguments
		errorReturn
	fi
	dims $datafilepath
	#rm -f $datafilepath # TODO
elif [ "$1" = "transpose" ]
then
	datafilepath="datafile$$"
	if [ "$#" = "1" ]
	then
		cat > "$datafilepath"
	elif [ "$#" = "2" ]
	then
		if [[ -r $2 ]]
		then
			datafilepath=$2
		else
			>&2 echo The file you gave is not readable
			errorReturn
		fi

	else 
		>&2 echo You did not pass the correct number of arguments
		errorReturn
	fi
	transpose $datafilepath
elif [ "$1" = "mean" ]
then
	datafilepath="datafile$$"
	if [ "$#" = "1" ]
	then
		cat > "$datafilepath"
	elif [ "$#" = "2" ]
	then
		if [[ -r $2 ]]
		then
			datafilepath=$2
		else
			>&2 echo The file you gave is not readable
			errorReturn
		fi
	else 
		>&2 echo You did not pass the correct number of arguments
		errorReturn
	fi
	mean $datafilepath
elif [ "$1" = "add" ]
then
	datafilepath1="datafile$$"
	datafilepath2="datafile$$"
	if [ "$#" = "3" ]
	then
		if [[ -r $2 && -r $3 ]]
		then
			datafilepath1=$2
			datafilepath2=$3
		else
			>&2 echo The file you gave is not readable
			errorReturn
		fi
	else
		>&2 echo You did not pass the correct number of arguments
		errorReturn
	fi
	add $datafilepath1 $datafilepath2
elif [ "$1" = "multiply" ]
then
	datafilepath1="datafile$$"
	datafilepath2="datafile$$"
	if [ "$#" = "3" ]
	then
		if [[ -r $2 && -r $3 ]]
		then
			datafilepath1=$2
			datafilepath2=$3
		else
			>&2 echo The file you gave is not readable
			errorReturn
		fi
	else
		>&2 echo You did not pass the correct number of arguments
		errorReturn
	fi
	#multiply $datafilepath1 $datafilepath2
else 
	>&2 echo Command not recognized
	errorReturn	
fi
